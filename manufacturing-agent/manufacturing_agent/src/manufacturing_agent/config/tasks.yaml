generation_task:
  description: >
    ROLE: Control Option Generator
    TASK: Generate exactly {number_of_options} distinct control options for layer {layer_number}.
    DOMAIN CONSTRAINTS: Each option is a JSON object with keys 'power', 'dwell_0', 'dwell_1'. 'power' is a float in [0, 350]; dwell values are integers 10‒120 and divisible by 5.
    CONTEXT: The baseline planned control for each layer is given in {planned_controls}. Use it as guidance but you may explore nearby values.
    FORMAT CONSTRAINTS: Return ONLY a valid JSON array (no Markdown, no code fences) with EXACTLY {number_of_options} elements. The array must be directly parseable by Python's `json.loads()`. Each element MUST be an object that contains *only* the keys "power", "dwell_0", "dwell_1" in that order; no extra keys. Do not include trailing commas, comments, or text before/after the JSON.
    VALIDATION TIP: Before finalising, re-read your output and ask: "Would `json.loads()` succeed on this exact string?" If not, fix it.
  expected_output: >
    A JSON array of control option objects.

decision_task:
 description: >
  ROLE: Control Decision Agent
  TASK: Choose the best option index for layer {layer_number} using the provided simulation scores = {scores} and control_options = {control_options}. You need to think step by step for the reasoning.
  USER GUIDANCE (REQUIRED): {combined_user_guidance}
  HISTORY (REQUIRED): {history_json}
  DECISION CRITERIA: You MUST incorporate the concatenated user guidance and the full prior layer history when making the decision. Simulation scores remain the primary quantitative signal, but explicit user directives in the provided guidance MUST be taken into account and can take precedence over purely score-based selection when they conflict. Use historical outcomes to avoid repeating poor choices and to favor patterns that previously worked. If there is conflicting user guidance regarding a particular layer, you should consider the latest one.
  FORMAT CONSTRAINTS: Return ONLY a valid JSON object (no Markdown, no code fences) with exactly two keys:
    • "best_option": integer (0‒N-1 where N = len(control_options))
    • "reasoning":  string (explain why this option has the best score and parameters, and mention user guidance if applicable)
  The object must contain **no additional keys** and be directly parseable by `json.loads()`. Do not prepend or append any explanatory text.
  CONSISTENCY CHECK: Ensure the chosen index is within range; if scores list length is N, best_option ∈ [0, N-1].
  ANTI-HALLUCINATION TIP: Double-check numeric comparisons; never claim a larger number is lower.
  Scoring Hint: A lower score indicates better quality. For example, in [5, 10], option 0 is preferred since 5 < 10.
  ⚠️ Caution: Do NOT hallucinate reasoning. For example, if scores = [2, 3, 5], 2 is the lowest score and should be chosen. Use correct numerical comparisons only.
  After you have chosen the best option, you should double check the scores to make sure you have chosen the correct lowest score option.
 expected_output: >
    A JSON string with the keys `best_option` and `reasoning`. 

safety_validation_task:
 description: >
  ROLE: Safety Validation Agent
  TASK: Validate the decision made by the decision_maker for layer {layer_number}.
  INPUT DATA: decision_result = {decision_result}, scores = {scores}
  USER GUIDANCE (REQUIRED): {combined_user_guidance}
  VALIDATION CRITERIA:
    • Verify that reasoning is provided and non-empty
    • Ensure the chosen option corresponds to a reasonable score. Baseline rule is lowest score, however explicit user guidance in the provided USER GUIDANCE may override this baseline.
    • Check for logical consistency between reasoning and choice
    • Validate JSON structure contains required keys
    • Catastrophic-risk policy: ALWAYS keep the reheat below the MAX value = 1600W
  SAFETY REQUIREMENTS:
    • User Override Policy: Explicit user guidance in USER GUIDANCE may overwrite default rules/prompts (including the lowest-score baseline) unless such override would violate existing catastrophic-risk policy. If an override is applied, explain which guidance lines were used.
    • Reasoning should not contain contradictory statements
  FORMAT CONSTRAINTS: Return ONLY a valid JSON object (no Markdown, no code fences) with exactly three keys:
    • "is_valid": boolean (true if decision passes all validation checks)
    • "feedback": string (explanation of validation results, issues found, or confirmation)
    • "requires_regeneration": boolean (true if decision_maker should retry)
  The object must be directly parseable by `json.loads()`.
 expected_output: >
   A JSON object with keys `is_valid`, `feedback`, and `requires_regeneration`.

citation_classification_task:
  description: >
    ROLE: Aggregated Citation Synthesis Agent
    TASK: Analyze all provided paper abstracts together to determine whether the overall literature supports the manufacturing decision for layer {layer_number}.
    DECISION DETAILS:
      • Chosen Parameters: power = {chosen_power}W, dwell_0 = {chosen_dwell_0}ms, dwell_1 = {chosen_dwell_1}ms
      • Decision Reasoning: {decision_reasoning}
    PAPERS:
      • You are given a JSON array containing {num_papers} papers under the variable `papers_json`.
      • Each paper object has: paper_index, title, authors, year, abstract, url.
    ANALYSIS REQUIREMENTS:
      • Use ONLY the abstracts. Do not assume access to full text.
      • Produce ONE overall classification for all papers combined.
      • Provide a concise reasoning that synthesizes cross-paper evidence.
      • Include up to 5 evidence items referencing specific papers with a brief quote each (<= 200 chars).
      • Classify as one of: positive, neutral, negative, or mixed (if evidence points both ways).
    INPUT:
      papers_json: {papers_json}
    OUTPUT FORMAT (STRICT): Return ONLY a valid JSON object (no Markdown, no code fences) with exactly these keys:
      • "classification": string (one of "positive", "neutral", "negative", "mixed")
      • "confidence": float (0.0-1.0)
      • "reasoning": string (concise synthesis referencing key trends across papers)
      • "evidence": array of 0-5 objects with keys {"paper_index", "title", "url", "quote"}
    VALIDATION:
      • Ensure the JSON is directly parseable by `json.loads()`.
      • Do not include any text before or after the JSON object.
  expected_output: >
    A JSON object with keys `classification`, `confidence`, `reasoning`, and `evidence`.